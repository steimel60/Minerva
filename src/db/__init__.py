from typing import Optional
import pathlib
import sqlite3

import logging
logging.basicConfig(filename="minerva.log", level=logging.DEBUG)

dbs_dir = "Organizations"

def run_SQL_script(db: sqlite3.Connection, sql_file: pathlib.Path) -> None:
    """Execute SQL commands in a file"""
    if not sql_file.is_file() or sql_file.suffix != ".sql":
        raise FileNotFoundError(
            f"Could not find sql file at: {sql_file}"
        )

    try:
        db.executescript(sql_file.read_text())
    except OSError as e:
        logging.debug(f"Couldn't read file: {sql_file}")
    except sqlite3.Error as e:
        logging.debug(f"Couldnt execute script in {sql_file}")

def setup(
        base_dir: pathlib.Path, 
        orgs: list[str], 
        sql_init_files: list[pathlib.Path]
    ) -> None:
    dbs_dir = base_dir / "Organizations" # overwrite global
    if not dbs_dir.exists():
        dbs_dir.mkdir()

    for o in orgs:
        # eventually handle errors generated by the below. note however that
        # such error handling is nearly pointless, in the sense that the
        # program should terminate if any db connections are unsuccessful,
        # or any sql script erroneous
        with sqlite3.connect((dbs_dir / o).with_suffix(".db")) as conn:
            for f in sql_init_files:
                # ensure scripts are non-destructive!!!
                run_SQL_script(conn, f)

# customer purchases
def generate_sql_result(
    conn: sqlite3.Connection,
    query: str,
    args: tuple,
) -> Optional[tuple]:
    try:
        with conn:
            query_obj = conn.cursor().execute(query, args)
            while next_row := query_obj.fetchone():
                yield next_row
    except Exception as e:
        logging.debug(f"Bad SQL: {e}")
        return None
    finally:
        return None
